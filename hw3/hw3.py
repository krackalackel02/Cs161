##############
# Homework 3 #
##############


###################
# Read This First #
###################


# All functions that you need to modify are marked with 'EXERCISE' in their header comments.
# Do not modify astar.py
# This file also contains many helper functions. You may call any of them in your functions.


# Due to the memory limitation, the A* algorithm may crash on some hard sokoban problems if too many
# nodes are generated. Improving the quality of the heuristic will mitigate
# this problem, as it will allow A* to solve hard problems with fewer node expansions.


# Remember that most functions are not graded on efficiency (only correctness).
# Efficiency can only influence your heuristic performance in the competition (which will affect your score).


# Load the astar.py and do not modify it.
import astar
# Load the numpy package and the state is represented as a numpy array during this homework.
import numpy as np
# Load the time package to measure the time of your algorithm.
import time


# a_star perform the A* algorithm with the start_state (numpy array), goal_test (function), successors (function) and
# heuristic (function). a_star prints the solution from start_state to goal_state (path), calculates the number of
# generated nodes (node_generated) and expanded nodes (node_expanded), and the solution depth (len(path)-1). a_star
# also provides the following functions for printing states and moves: prettyMoves(path): Translate the solution to a
# list of moves printlists(path): Visualize the solution and Print a list of states
def a_star(start_state, goal_test, successors, heuristic):
    goal_node, node_generated, node_expanded = astar.a_star_search(start_state, goal_test, successors, heuristic)
    if goal_node:
        node = goal_node
        path = [node.state1]
        while node.parent:
            node = node.parent
            path.append(node.state1)
        path.reverse()

        # print('My path:{}'.format(path))
        # print(prettyMoves(path))
        # printlists(path)
        print('Nodes Generated by A*: {}'.format(node_generated))
        print('Nodes Expanded by A*: {}'.format(node_expanded))
        print('Solution Depth: {}'.format(len(path) - 1))
    else:
        print('no solution found')


# A shortcut function
# Transform the input state to numpy array. For other functions, the state s is presented as a numpy array.
# Goal-test and next-states stay the same throughout the assignment
# You can just call sokoban(init-state, heuristic function) to test the result
def sokoban(s, h):
    return a_star(np.array(s), goal_test, next_states, h)


# Define some global variables
blank = 0
wall = 1
box = 2
keeper = 3
star = 4
boxstar = 5
keeperstar = 6


# Some helper functions for checking the content of a square
def isBlank(v):
    return (v == blank)


def isWall(v):
    return (v == wall)


def isBox(v):
    return (v == box)


def isKeeper(v):
    return (v == keeper)


def isStar(v):
    return (v == star)


def isBoxstar(v):
    return (v == boxstar)


def isKeeperstar(v):
    return (v == keeperstar)


# Help function for get KeeperPosition
# Given state s (numpy array), return the position of the keeper by row, col
# The top row is the zeroth row
# The first (right) column is the zeroth column
def getKeeperPosition(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            if (isKeeper(s[i, j]) or isKeeperstar(s[i, j])):
                return i, j


# For input list s_list, remove all None element
# For example, if s_list = [1, 2, None, 3], returns [1, 2, 3]
def cleanUpList(s_list):
    clean = []
    for state in s_list:
        if state is not None:
            clean.append(state)
    return clean


# EXERCISE: Modify this function to return Ture
# if and only if s (numpy array) is a goal state of a Sokoban game.
# (no box is on a non-goal square)
# Remember, the number of goal can be larger than the number of box.
def goal_test(s):
    for row in s:
        for val in row:
            if val == box:  # box not on goal
                return False
    return True

def get_square(s, r, c):
    if 0 <= r < s.shape[0] and 0 <= c < s.shape[1]:
        return s[r, c]
    return wall
def set_square(s, r, c, v):
    s_copy = np.copy(s)
    s_copy[r, c] = v
    return s_copy

# Attempt to move the keeper in direction (dr, dc).
# Returns the resulting state if the move is legal, or None if illegal.
# Sokoban move rules:
#   - Keeper can move into a blank square or a goal.
#   - Keeper can push a box if the square beyond is free (blank or goal).
#   - Cannot walk into walls or push boxes into blocked spaces.
def try_move(s, dr, dc):
    # Get current position of the keeper
    r, c = getKeeperPosition(s)

    # Compute the square directly adjacent (where keeper wants to go)
    r1, c1 = r + dr, c + dc

    # Compute the square two steps away (used when pushing a box)
    r2, c2 = r1 + dr, c1 + dc

    # Identify what is currently in the relevant squares
    from_val = s[r, c]               # current keeper square
    to_val = get_square(s, r1, c1)   # square keeper moves into
    beyond_val = get_square(s, r2, c2)  # square beyond that (for pushing)

    # If trying to walk into a wall, move is illegal
    if isWall(to_val):
        return None

    # Work on a copy of the current state to avoid modifying the original
    s1 = np.copy(s)

    # --- Case 1: Trying to push a box ---
    if isBox(to_val) or isBoxstar(to_val):
        # You can only push the box if the next square is empty or a goal
        if not (isBlank(beyond_val) or isStar(beyond_val)):
            return None  # push blocked, move is invalid

        # Move the box to the destination square (update with correct visual)
        s1 = set_square(s1, r2, c2, boxstar if isStar(beyond_val) else box)
        beyond_val = get_square(s1, r2, c2)  # update the box's new value

        # Clear the box's previous position
        s1 = set_square(s1, r1, c1, star if isBoxstar(to_val) else blank)
        to_val = get_square(s1, r1, c1)  # update the box's new value

    # --- Case 2: Update the square the keeper is leaving ---
    # If the keeper was on a goal, leave a goal behind; otherwise, just empty space
    s1 = set_square(s1, r, c, star if isKeeperstar(from_val) else blank)

    # --- Case 3: Move the keeper into the new square ---
    # If the destination is a goal square, use keeperstar; else just keeper
    s1 = set_square(s1, r1, c1, keeperstar if isStar(to_val) else keeper)

    # Return the new state after the move
    return s1


# EXERCISE: Modify this function to return the list of
# successor states of s (numpy array).
#
# This is the top-level next-states (successor) function.
# Some skeleton code is provided below.
# You may delete them totally, depending on your approach.
# 
# If you want to use it, you will need to set 'result' to be 
# the set of states after moving the keeper in each of the 4 directions.
#
# You can define the function try-move and decide how to represent UP,DOWN,LEFT,RIGHT.
# Any None result in the list can be removed by cleanUpList.
#
# When generated the successors states, you may need to copy the current state s (numpy array).
# A shallow copy (e.g, direcly set s1 = s) constructs a new compound object and then inserts references 
# into it to the objects found in the original. In this case, any change in the numpy array s1 will also affect
# the original array s. Thus, you may need a deep copy (e.g, s1 = np.copy(s)) to construct an indepedent array.
def next_states(s):
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
    result = []

    for dr, dc in directions:
        new_state = try_move(s, dr, dc)
        result.append(new_state)

    return cleanUpList(result)



# EXERCISE: Modify this function to compute the trivial
# admissible heuristic.
def h0(s):
    return 0

# EXERCISE: Modify this function to compute the
# number of misplaced boxes in state s (numpy array).
def h1(s):
    misplaced = 0
    for row in s:
        for val in row:
            if val == box:
                misplaced += 1
    return misplaced

# EXERCISE: Is this heuristic admissible? Return true if yes, false if no. Explain your reasoning
# as comments in this function.
def h1_admissible():
    # This heuristic counts the number of boxes not on goals.
    # It does not overestimate the number of steps required to reach the goal,
    # because each misplaced box must be moved at least once.
    # It ignores path complexity and distances, so it is a lower bound.
    return True

# EXERCISE: 
# This function will be tested in various hard examples.
# Objective: make A* solve problems as fast as possible.

# Heuristic function h2: estimates cost from state s to goal
# This version assigns each box to the nearest available goal using greedy matching.
# It is admissible (never overestimates) and performs better than h0 or h1.

# --- WHY THIS HEURISTIC IS ADMISSIBLE ---
# The heuristic estimates the minimum cost to reach the goal by:
#   - Pairing each box with the closest unassigned goal using Manhattan distance
#   - Ignoring obstacles and actual path feasibility (e.g., walls or pushing constraints)
# Because it only considers the *shortest possible* straight-line movement to goal positions:
#   - It may *underestimate* the cost (if pushing is hard or blocked),
#   - But it will *never overestimate* the true cost to the goal.
# Therefore, h2 is guaranteed to be **admissible**.
# -----------------------------------------

def h2(s):
    boxes = []  # List to store positions of all boxes
    goals = []  # List to store positions of all goal squares

    # Step 1: Collect positions of all boxes and goals
    for r in range(s.shape[0]):
        for c in range(s.shape[1]):
            # Add any type of box (normal or on goal)
            if isBox(s[r, c]) or isBoxstar(s[r, c]):
                boxes.append((r, c))
            # Add any type of goal (empty, under box, or under keeper)
            if isStar(s[r, c]) or isBoxstar(s[r, c]) or isKeeperstar(s[r, c]):
                goals.append((r, c))

    total_distance = 0     # Total heuristic cost (to be returned)
    used_goals = set()     # Track which goals have already been paired with a box

    # Step 2: Assign each box to its closest unassigned goal
    for box in boxes:
        min_dist = float('inf')  # Initialize the minimum distance as infinity
        closest_goal = None      # Placeholder for the best goal candidate

        # Loop through all goals to find the closest available one
        for goal in goals:
            if goal in used_goals:
                continue  # Skip goals that are already assigned to another box

            # Compute Manhattan distance between box and goal
            dist = abs(box[0] - goal[0]) + abs(box[1] - goal[1])

            # Update closest goal if this one is closer
            if dist < min_dist:
                min_dist = dist
                closest_goal = goal

        # Once a goal is selected, mark it used and accumulate its distance
        if closest_goal:
            used_goals.add(closest_goal)
            total_distance += min_dist

    # Step 3: Return the total estimated cost
    return total_distance




# Some predefined problems with initial state s (array). Sokoban function will automatically transform it to numpy
# array. For other function, the state s is presented as a numpy array. You can just call sokoban(init-state,
# heuristic function) to test the result Each problem can be visualized by calling prettyMoves(path) and printlists(
# path) in a_star function
#
# Problems are roughly ordered by their difficulties.
# For most problems, we also provide 2 additional number per problem:
#    1) # of nodes expanded by A* using our next-states and h0 heuristic.
#    2) the depth of the optimal solution.
# These numbers are located at the comments of the problems. For example, the first problem below 
# was solved by 80 nodes expansion of A* and its optimal solution depth is 7.
# 
# Your implementation may not result in the same number of nodes expanded, but it should probably
# give something in the same ballpark. As for the solution depth, any admissible heuristic must 
# make A* return an optimal solution. So, the depths of the optimal solutions provided could be used
# for checking whether your heuristic is admissible.
#
# Warning: some problems toward the end are quite hard and could be impossible to solve without a good heuristic!


# [80,7]
s1 = [[1, 1, 1, 1, 1, 1],
      [1, 0, 3, 0, 0, 1],
      [1, 0, 2, 0, 0, 1],
      [1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [110,10],
s2 = [[1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 2, 1, 4, 1],
      [1, 3, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 1, 1]]

# [211,12],
s3 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 2, 0, 3, 4, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [300,13],
s4 = [[1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 1, 4],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 1, 1, 1, 0, 0],
      [0, 0, 1, 0, 0, 0, 0],
      [0, 2, 1, 0, 0, 0, 0],
      [0, 3, 1, 0, 0, 0, 0]]

# [551,10],
s5 = [[1, 1, 1, 1, 1, 1],
      [1, 1, 0, 0, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 4, 2, 2, 4, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 1, 3, 1, 1, 1],
      [1, 1, 1, 1, 1, 1]]

# [722,12],
s6 = [[1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 4, 1],
      [1, 0, 0, 0, 2, 2, 3, 1],
      [1, 0, 0, 1, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1, 1, 1]]

# [1738,50],
s7 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 1, 1, 1, 1, 0, 0, 0, 3],
      [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
      [0, 2, 1, 0, 0, 0, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 0, 0, 0, 1, 4]]

# [1763,22],
s8 = [[1, 1, 1, 1, 1, 1],
      [1, 4, 0, 0, 4, 1],
      [1, 0, 2, 2, 0, 1],
      [1, 2, 0, 1, 0, 1],
      [1, 3, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [1806,41],
s9 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 0, 0, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 2, 0, 1],
      [1, 0, 1, 0, 0, 1, 2, 0, 1],
      [1, 0, 4, 0, 4, 1, 3, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [10082,51],
s10 = [[1, 1, 1, 1, 1, 0, 0],
       [1, 0, 0, 0, 1, 1, 0],
       [1, 3, 2, 0, 0, 1, 1],
       [1, 1, 0, 2, 0, 0, 1],
       [0, 1, 1, 0, 2, 0, 1],
       [0, 0, 1, 1, 0, 0, 1],
       [0, 0, 0, 1, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 1, 1]]

# [16517,48],
s11 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 4, 1],
       [1, 0, 2, 2, 1, 0, 1],
       [1, 0, 2, 0, 1, 3, 1],
       [1, 1, 2, 0, 1, 0, 1],
       [1, 4, 0, 0, 4, 0, 1],
       [1, 1, 1, 1, 1, 1, 1]]

# [22035,38],
s12 = [[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
       [1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1],
       [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 2, 1, 1, 1, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 1, 0, 1, 4, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1]]

# [26905,28],
s13 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 2, 0, 1],
       [1, 0, 2, 0, 0, 0, 0, 0, 4, 1],
       [1, 0, 3, 0, 0, 0, 0, 0, 2, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [41715,53],
s14 = [[0, 0, 1, 0, 0, 0, 0],
       [0, 2, 1, 4, 0, 0, 0],
       [0, 2, 0, 4, 0, 0, 0],
       [3, 2, 1, 1, 1, 0, 0],
       [0, 0, 1, 4, 0, 0, 0]]

# [48695,44],
s15 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 2, 2, 0, 1],
       [1, 0, 2, 0, 2, 3, 1],
       [1, 4, 4, 1, 1, 1, 1],
       [1, 4, 4, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0]]

# [91344,111],
s16 = [[1, 1, 1, 1, 1, 0, 0, 0],
       [1, 0, 0, 0, 1, 0, 0, 0],
       [1, 2, 1, 0, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 5, 0, 5, 0, 1],
       [1, 0, 5, 0, 1, 0, 1, 1],
       [1, 1, 1, 0, 3, 0, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 0]]

# [3301278,76],
# Warning: This problem is very hard and could be impossible to solve without a good heuristic!
s17 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 3, 0, 0, 1, 0, 0, 0, 4, 1],
       [1, 0, 2, 0, 2, 0, 0, 4, 4, 1],
       [1, 0, 2, 2, 2, 1, 1, 4, 4, 1],
       [1, 0, 0, 0, 0, 1, 1, 4, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]

# [??,25],
s18 = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 4, 1, 0, 0, 0, 0]]

# [??,21],
s19 = [[0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 4],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 2, 0, 4, 1, 0, 0, 0]]


# Utility functions for printing states and moves.
# You do not need to understand any of the functions below this point.


# Helper function of prettyMoves
# Detect the move from state s --> s1
def detectDiff(s, s1):
    row, col = getKeeperPosition(s)
    row1, col1 = getKeeperPosition(s1)
    if (row1 == row + 1):
        return 'Down'
    if (row1 == row - 1):
        return 'Up'
    if (col1 == col + 1):
        return 'Right'
    if (col1 == col - 1):
        return 'Left'
    return 'fail'


# Translates a list of states into a list of moves
def prettyMoves(lists):
    initial = 0
    action = []
    for states in (lists):
        if (initial != 0):
            action.append(detectDiff(previous, states))
        initial = 1
        previous = states
    return action


# Print the content of the square to stdout.
def printsquare(v):
    if (v == blank):
        print(' ', end='')
    if (v == wall):
        print('#', end='')
    if (v == box):
        print('$', end='')
    if (v == keeper):
        print('@', end='')
    if (v == star):
        print('.', end='')
    if (v == boxstar):
        print('*', end='')
    if (v == keeperstar):
        print('+', end='')


# Print a state
def printstate(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            printsquare(s[i, j])
        print('\n')


# Print a list of states with delay.
def printlists(lists):
    for states in (lists):
        myprintstate(states)
        print('\n')

# custom print to view puzzle in a more readable format
def myprintstate(s,scale=2):
    symbol_map = {
        blank: ' ',
        wall: '█',
        box: '▣',
        keeper: '⛹',
        star: '△',
        boxstar: '◆',
        keeperstar: '🔷'
    }

    row, col = s.shape
    top_border = '┌' + '─'*scale* col + '┐'
    bottom_border = '└' + '─'*scale * col + '┘'
    print(top_border)
    for i in range(row):
        print('│', end='')
        for j in range(col):
            if s[i, j] == keeperstar:
                print(symbol_map.get(s[i, j], '?'), end='')
            else:
                print(symbol_map.get(s[i, j], '?') * scale, end='')
        print('│')
    print(bottom_border)


def test_next_states(state = s16 ):
    # Example test case: Keeper pushes the box or moves around it
    test_s = [
        [1, 1, 1, 1, 1],
        [1, 3, 2, 4, 1],
        [1, 0, 0, 0, 1],
        [1, 0, 0, 0, 1],
        [1, 0, 0, 0, 1],
        [1, 1, 1, 1, 1]
    ]

    if state is not None:
        test_s = state

    print("Initial State:")
    myprintstate(np.array(test_s))

    print("\nSuccessor States from next_states():\n")
    succs = next_states(np.array(test_s))
    for i, state in enumerate(succs):
        print(f"Successor {i + 1}:")
        myprintstate(state)
        print()
def test_h( heuristic=h0):
    sokoban(s1, heuristic)
    sokoban(s2, heuristic)
    sokoban(s3, heuristic)
    sokoban(s4, heuristic)
def custom_test_h(heuristic=h0,state=None):
    ss = (
        (1, s1, True),
        (2, s2, True),
        (3, s3, True),
        (4, s4, True),
        (5, s5, True),
        (6, s6, True),
        (7, s7, True),
        (8, s8, True),
        (9, s9, True),
        (10, s10, True),
        (11, s11, True),
        (12, s12, True),
        (13, s13, True),
        (14, s14, True),
        (15, s15, True),
        (16, s16, True),
        (17, s17, True),
        (18, s18, True),
        (19, s19, True),
    )
    total_time = 0
    if state is not None:
        ss = [('Custom', state, True)]
    for i, s, d in ss:
        print(f"Test {i}{'' if d else ' (skipped)'}")
        state = np.array(s)
        myprintstate(state)
        if d:
            start_time = time.time()
            sokoban(state, heuristic)
            end_time = time.time()
            total_time += end_time - start_time
            print(f"Execution Time: {end_time - start_time:.4f} seconds")
            print()

    print(f"Total Time: {total_time:.4f} seconds")
if __name__ == "__main__":
    # test_h(h0)
    # test_h(h1)
    # test_h(h2)
    # test_next_states(
    #     [[1, 1, 1, 1, 1, 0, 0, 0],
    #    [1, 0, 0, 0, 1, 0, 0, 0],
    #    [1, 2, 1, 0, 1, 1, 1, 1],
    #    [1, 4, 0, 0, 0, 0, 0, 1],
    #    [1, 0, 0, 5, 0, 5, 0, 1],
    #    [1, 0, 5, 3, 1, 0, 1, 1],
    #    [1, 1, 1, 0, 0, 0, 1, 0],
    #    [0, 0, 1, 1, 1, 1, 1, 0]])
    # custom_test_h(h0,s16)
    custom_test_h(h2)

    

    